<?php

namespace App\Entity\Repository;
use App\Entity\forForm\search\docFromParam;
use App\Utilits\Analiz\Exception\noCorrectDataException;
use App\Utilits\Analiz\Exception\noCorrectRoutingSearchException;
use App\Utilits\Analiz\prepareSQL\prepareSQLToReestr;
use App\Utilits\Analiz\workDateForSQL;
use Doctrine\DBAL\DBALException;
use Doctrine\ORM\EntityRepository;
use Exception;

/**
 * ReestrBranch_in
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ReestrBranch_in extends EntityRepository
{
    /**
     * поиск данных в Реестре выданых НН по параметрам
     *
     * @uses allFromPeriod_Branch класс поиска
     * @uses allFromPeriod_Branch::getArrayFromSearchErpn возвращает данные для $arrayFromSearch
     *
     * использованные расширения
     * @link  https://simukti.net/blog/2012/04/05/how-to-select-year-month-day-in-doctrine2/
     * @link  https://github.com/beberlei/DoctrineExtensions
     *
     * @deprecated
     * @param $arrayFromSearch
     * @return mixed
     */
	public function getSearchAllFromPeriod_Branch($arrayFromSearch)
	{
		$emConfig = $this->getEntityManager()->getConfiguration();
		$emConfig->addCustomDatetimeFunction('YEAR', 'DoctrineExtensions\Query\Mysql\Year');
		$emConfig->addCustomDatetimeFunction('MONTH', 'DoctrineExtensions\Query\Mysql\Month');

		$qr=$this->createQueryBuilder('ReestrIn');
		$qr->where('MONTH(ReestrIn.dateCreateInvoice)=:m');
		$qr->setParameter('m', $arrayFromSearch['monthCreateInvoice']);
		$qr->andWhere('YEAR(ReestrIn.dateCreateInvoice)=:y');
		$qr->setParameter('y', $arrayFromSearch['yearCreateInvoice']);

		if(array_key_exists('numMainBranch', $arrayFromSearch))
		{
			$qr->andWhere('ReestrIn.numBranch=:nb');
			$qr->setParameter('nb', $arrayFromSearch['numMainBranch']);
		}

		$result=$qr->getQuery();
		return $result->getResult();
	}

    /**
     * поиск данных в Реестре выданых НН по параметрам
     *
     * @uses docFromParam класс поиска
     * @uses docFromParam::getArrayFromSearchErpn возвращает данные для $arrayFromSearch
     *
     * использованные расширения
     * @link  https://simukti.net/blog/2012/04/05/how-to-select-year-month-day-in-doctrine2/
     * @link  https://github.com/beberlei/DoctrineExtensions
     *
     * @deprecated
     * @param $arrayFromSearch
     * @return mixed
     */
	public function getSearchAllFromParam($arrayFromSearch)
	{
		$emConfig = $this->getEntityManager()->getConfiguration();
		$emConfig->addCustomDatetimeFunction('YEAR', 'DoctrineExtensions\Query\Mysql\Year');
		$emConfig->addCustomDatetimeFunction('MONTH', 'DoctrineExtensions\Query\Mysql\Month');

		$qr=$this->createQueryBuilder('ReestrIn');
		$qr->where('MONTH(ReestrIn.dateCreateInvoice)=:m');
		$qr->setParameter('m', $arrayFromSearch['monthCreateInvoice']);
		$qr->andWhere('YEAR(ReestrIn.dateCreateInvoice)=:y');
		$qr->setParameter('y', $arrayFromSearch['yearCreateInvoice']);
		$qr->andWhere('ReestrIn.typeInvoiceFull=:tif');
		$qr->setParameter('tif', $arrayFromSearch['typeInvoiceFull']);

		if(array_key_exists('innClient', $arrayFromSearch))
		{
			$qr->andWhere('ReestrIn.innClient=:inn');
			$qr->setParameter('inn', $arrayFromSearch['innClient']);
		}

		if(array_key_exists('numInvoice', $arrayFromSearch))
		{
			$qr->andWhere('ReestrIn.numInvoice=:ni');
			$qr->setParameter('ni', $arrayFromSearch['numInvoice']);
		}

		if(array_key_exists('dateCreateInvoice', $arrayFromSearch))
		{
			$qr->andWhere('ReestrIn.dateCreateInvoice=:dсi');
			$qr->setParameter('dсi', $arrayFromSearch['dateCreateInvoice']);
		}


		$result=$qr->getQuery();
		return $result->getResult();
	}

    /** Поиск данных в таблице на основании параметров переданных в объекте docFromParam
     * @param docFromParam $param
     * @see  searchReestrFromParam::getSearchData()
     * @return mixed
     */
    public function searchDataFromParam(docFromParam $param)
    {
        $objParam = $param;
//        $emConfig = $this->getEntityManager()->getConfiguration();
//        $emConfig->addCustomDatetimeFunction('YEAR', 'DoctrineExtensions\Query\Mysql\Year');
//        $emConfig->addCustomDatetimeFunction('MONTH', 'DoctrineExtensions\Query\Mysql\Month');
        $qr = $this->createQueryBuilder('reestr_branch_in');

        $qr->where('MONTH(reestr_branch_in.dateCreateInvoice)=:m');
        $qr->setParameter('m', $objParam->getMonthCreate());

        $qr->andWhere('YEAR(reestr_branch_in.dateCreateInvoice)=:y');
        $qr->setParameter('y', $objParam->getYearCreate());

        $qr->andWhere('reestr_branch_in.typeInvoiceFull=:t');
        $qr->setParameter('t', $objParam->getTypeDoc());

        if ($objParam->getDateCreateDoc() != null) {
            $qr->andWhere('reestr_branch_in.dateCreateInvoice=:d');
            $qr->setParameter('d', $objParam->getDateCreateDoc());
        }

        if ($objParam->getINN() != 0) {
            $qr->andWhere('reestr_branch_in.innClient=:i');
            $qr->setParameter('i', $objParam->getINN());
        }

        if ($objParam->getNumDoc() != 0) {
            $qr->andWhere('reestr_branch_in.numInvoice=:ni');
            $qr->setParameter('ni', $objParam->getNumDoc());
        }

        $result = $qr->getQuery();
        return $result->getResult();
    }

    /**
     * Получение "сырых" данных для анализа
     * @param int $month - месяц проведения анализа
     * @param int $year - год проведения анализа
     * @return array
     * @throws noCorrectDataException
     * @throws noCorrectRoutingSearchException
     * @throws Exception
     */
    public function getArrayRecordsForAnaliz(int $month, int $year){
        $obj = new workDateForSQL($month,$year);
        $sql = prepareSQLToReestr::getPrepareSQL('ReestrIn');
        return $this->executeSQLWithReturn(
            $sql,
            $obj->getArrayForBindValueWithoutPeriod()
        );
    }

    /**
     * Формирование запроса который возвращает результат своей работы
     * @param string $SQL текст запроса
     * @param array $paramBind параметры запросе
     * @return array
     * @throws DBALException
     */
    private function executeSQLWithReturn(string $SQL, array $paramBind=null):array {
        $smtp=$this->_em->getConnection()->prepare($SQL);
        if(!is_null($paramBind)){
            foreach ($paramBind as $key=>$value){
                $smtp->bindValue("$key", $value);
            }
        }
        $smtp->execute();
        $arrayResult=$smtp->fetchAll();
        return $arrayResult;
    }
}
